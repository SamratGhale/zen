// This is a comment!
// Import other packages with the `import` keyword.
import "io" // Import the io package from the standard library.
import "./hello" // Import the hello package from a directory called hello.

// Hello world!
print "Hello, world!"
print "Hello, again!"; // Semicolons are optional.

let name = "Sam" // Create a variable!
let another_name string = "Jamie" // Explicitly type it
let not_initialized string // Must give this a type
final nice = 69 // You can't reassign to this!

// You can group variable declarations together.
let (
    age = 21
    is_cool bool = true
    unknown bool
)

// Also works with final variables.
final (
    is_nice = true
    is_not_nice = false
)


// Strings can be subscripted and have convenience methods too.
print name[0] //=> "S"
print name.len //=> 3
print name.upcase() //=> "SAM"

print f"{nice} is very nice indeed" // String interpolation!

// Conditionals!
if false {
    print "How did this happen!"
} else if true {
    print "This is supposed to happen"
}

let a = rand_int(0, 10)

match a {
    0 => print "a is 0"
    1 => print "a is 1"
    2 => print "a is 2"
    3 => print "a is 3"
    4 => print "a is 4"
    5 => print "a is 5"
    6 => print "a is 6"
    7 => print "a is 7"
    8 => print "a is 8"
    9 => print "a is 9"
    10 => print "a is 10"
    _ => print "a is not between 0 and 10"
}

let hmm = "Nice" if nice == 69 else "Not nice" // Ternary if-else

// Loops.
// All loops are for loops.
for i in 0..=10 { // Inclusive range
    print f"{i} "
} // 0 1 2 3 4 5 6 7 8 9 10

for i in 0..<10; step 2 { // Exclusive range, index incremented by 2
    print f"{i} "
} // 0 2 4 6 8

let i = 0
for i < 10 { // While loops are spelled "for" in zen.
    print f"{i} "
} // 0 1 2 3 4 5 6 7 8 9

// Lists!
let lst []int = [1, 2, 3, 4, 5]
print lst[0] //=> 1
print lst.len //=> 5

lst.push(6) // Add an element to the end of the list.
print lst.last() //=> 6
lst.pop() // Remove the last element.
print lst.last() //=> 5

// Use the `has?` method to check if a list contains an element.
if lst.has?(3) {
    print "List has 3"
}

// Loop through lists with `for`.
for i in lst {
    print f"{i} "
} //=> 1 2 3 4 5

// You can change the step of the loop too!
for i in lst; step 2 {
    print f"{i} "
} //=> 1 3 5

// Maps!
// You can create maps to associate values with keys.
let people map[string]int = #{
    "Sam": 21,
    "Jamie": 20,
    "Alex": 19,
}

print people["Sam"] //=> 21
print people.size //=> 3

// You can check if a map contains a key with the `has_key?` method.
if people.has_key?("Sam") {
    print "Sam is in the map"
}

// You can loop through maps with `for`.
for name, age in people {
    print f"{name} is {age} years old"
} //=> Sam is 21 years old
  //=> Jamie is 20 years old
  //=> Alex is 19 years old

// Functions!
func a_function() {
    print "This is a function!"
}
a_function() //=> "This is a function!"

// If the function just returns an expression, simply use the `=>` operator.
func sum(a, b) -> a + b

// Anonymous functions have no name. Here, we assign it to a variable, so it
// isn't really anonymous anymore.
let anon = () -> { print "This is an anonymous function!" }
// Mentioning the argument types is optional, as they are inferred.

// Functions are first-class, so you can pass them around to other functions.
// Here's a recursive map function to demonstrate.
// This is also a good opportunity to introduce generics and pattern matching.

// This function is generic over T. The type T can be used in the function
// signature and body, and it basically is another parameter passed into
// the function (implicitly or explicitly, based on what you wish), except
// for the fact that its a type and not a value.
func map<T>(f fun(T) T, l list<T>) list<T> =>
    // Pattern matching! `match` is basically a switch statement on steroids.
    // Note that `match` is an expression, not a statement.
    // However, you can use it as a statement too, since its arms may be
    // expressions or statements.
    match l {
        [] => []
        [hd, ...tl] => [f(hd), ...map(f, tl)]
    }

// Note: You don't need to specify the type of the function arguments and 
// return types. They are inferred.
print map((x -> x * 2), [1, 2, 3, 4, 5]) //-> [2, 4, 6, 8, 10]

// Functions can return multiple values.
// Multiple return values are not the same as tuples.
func swap(a, b) -> (b, a)

// Where clauses also exist.
// They are used to specify constraints on generic types.
func print<T>(x T)
where 
    T.is_stringable() 
{
    print x.to_string()
}

print(something_that_is_definetely_not_stringable)
//! compile error at print(): Where clause evaluated to false

// OOPy stuff!
final Person = class {
    final (
        name string
        age int
    )

    // Create a constructor with the `construct` keyword.
    construct new(name, age) {
        this.name = name
        this.age = age
    }

    // All methods implicitly take `this` as the first argument.
    func create_greeting() {
        return f"Hello, I'm {this.name}!"
    }

    // All fields and functions are private by default, except
    // for constructors.
    pub func greet() {
        print this.create_greeting()
    }
}

// "Call" the class to create an instance of it.
let me = Person("Sam", 21)
me.greet() //=> "Hello, I'm Sam!"

// You can inherit from other classes.
final Student = class is Person {
    const school string

    construct new(name, age, school) {
        super(name, age) // Call the parent constructor.
        this.school = school
    }

    // Methods with the same name as the parent class override them.
    pub func greet() {
        print super.create_greeting()
        print f"I go to {this.school}"
    }
}

// Error handling!
// zen uses option and result types to handle errors.
// You use option types to denote something that may or may not exist.
// Similarly, you use result types to denote something that may or may not 
// be an error.

// Let's check out result first.
// Define your own error types with the `Error` class.
final DivideByZeroError = class is Error {
    // This is a getter. It is called when you access the `message` field.
    // The error class defines this `message` getter which is used
    // to provide custom error messages on whatever inherits it.
    message { "Cannot divide by zero!" }
}

// This function returns result<float, DivideByZeroError>.
// A result type is either a value enclosed in ok() or an value associated
// with an error enclosed in err().
func divide(a, b) ->
    match b {
        0 => err(DivideByZeroError())
        _ => ok(a / b)
    }

// Use unwrap() to get the value out of an option or result.
// If the option or result is empty or an error, it will panic with the
// default error message.
let answer = divide(10, 2).unwrap() //-> 5
let error = divide(10, 0).unwrap() 
//! panic at DivideByZeroError "Cannot divide by zero!"

// You can also use expect() to provide a custom error message.
let expects = divide(10, 0).expect("Can't set b as zero")
//! panic at DivideByZeroError "Can't set b as zero"

// A better idea is to use match to handle the result.
match divide(10, 2) {
    ok(x) => print f"10 / 2 = {x}"
    err(e) => print e
} //=> 10 / 2 = 5

// Even better, unwrap_or() and unwrap_or_else() let you provide a default
// value or function to call if the result is an error.
let answer = divide(10, 0).unwrap_or(0) //=> 0
let answer = divide(10, 0).unwrap_or_else((e) -> {
    print e
    return 0
}) //=> "Cannot divide by zero!"
   //=> 0

// Now, for option types.
// An option type is either a value enclosed in `some()` or a nonexistent
// value, represented as the variant `none`.
// Here's an example, using a function to get the first element of a list.
func get_first(l) ->
    match l {
        // when the list is empty, return none
        [] => none
        [hd, ...tl] => some(hd)
    }

// You can handle option types with unwrap, expect, match etc. just like you
// would with results.
let a = get_first([1, 2, 3]).unwrap() //=> 1
let b = get_first([]).unwrap() //! panic: "Can't unwrap none"
let c = get_first([]).expect("List is empty") //! panic at "List is empty"
